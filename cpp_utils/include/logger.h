// Generated by Co-pilot
#ifndef LOGGER_H
#define LOGGER_H

#include <iostream>
#include <string>
#include <cstring>
#include <chrono>
#include <iomanip>
#include <sstream>
#include <mutex>
#include <cstring>  

enum LogLevel {
    DEBUG,
    INFO,
    WARN,
    ERROR,
    FATAL
};

class Logger {
private:
    static inline std::mutex log_mutex_;
    static inline LogLevel global_level_ = INFO;  // Inline definition

    static std::string get_current_time() {
        auto now = std::chrono::system_clock::now();
        auto time = std::chrono::system_clock::to_time_t(now);
        std::stringstream ss;
        ss << std::put_time(std::localtime(&time), "%Y-%m-%d %H:%M:%S");
        return ss.str();
    }

public:
    static void set_level(LogLevel level) {
        global_level_ = level;
    }

    template<typename... Args>
    static void debug(const std::string& name, const std::string& msg, Args... args) {
        log(DEBUG, name, msg, args...);
    }

    template<typename... Args>
    static void info(const std::string& name, const std::string& msg, Args... args) {
        log(INFO, name, msg, args...);
    }

    template<typename... Args>
    static void warn(const std::string& name, const std::string& msg, Args... args) {
        log(WARN, name, msg, args...);
    }

    template<typename... Args>
    static void error(const std::string& name, const std::string& msg, Args... args) {
        log(ERROR, name, msg, args...);
    }

    template<typename... Args>
    static void fatal(const std::string& name, const std::string& msg, Args... args) {
        log(FATAL, name, msg, args...);
    }

    template<typename... Args>
    static void log(LogLevel level, const std::string& name, const std::string& msg, Args... args) {
        if (level < global_level_) return;

        std::string level_str;
        switch (level) {
            case DEBUG: level_str = "DEBUG"; break;
            case INFO:  level_str = "INFO"; break;
            case WARN:  level_str = "WARN"; break;
            case ERROR: level_str = "ERROR"; break;
            case FATAL: level_str = "FATAL"; break;
        }

        std::lock_guard<std::mutex> lock(log_mutex_);
        
        char buffer[1024];
        if constexpr (sizeof...(args) > 0) {
            // Use snprintf if there are additional arguments
            snprintf(buffer, sizeof(buffer), msg.c_str(), args...);
        } else {
            // Directly copy the message if there are no additional arguments
            strncpy(buffer, msg.c_str(), sizeof(buffer) - 1);
            buffer[sizeof(buffer) - 1] = '\0'; // Ensure null termination
        }
        
        std::cout << "[" << get_current_time() << "] [" << level_str << "] [" << name << "]: " 
                  << buffer << std::endl;
    }
};

#define LOGGER_DEBUG(name, ...) Logger::debug(name, __VA_ARGS__)
#define LOGGER_INFO(name, ...) Logger::info(name, __VA_ARGS__)
#define LOGGER_WARN(name, ...) Logger::warn(name, __VA_ARGS__)
#define LOGGER_ERROR(name, ...) Logger::error(name, __VA_ARGS__)
#define LOGGER_FATAL(name, ...) Logger::fatal(name, __VA_ARGS__)
#define LOGGER_DEBUG_EXPRESSION(name, condition, ...) \
    do { \
        if (condition) { \
            LOGGER_DEBUG(name, __VA_ARGS__); \
        } \
    } while(0)

#endif // LOGGER_H
